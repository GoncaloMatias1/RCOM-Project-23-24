application_layer.c

Constantes:
CONTROL_DATA, CONTROL_START, CONTROL_END: São códigos de controle para pacotes de dados, início e término.
FILE_SIZE, FILE_NAME: Identificadores para o tamanho do arquivo e nome do arquivo, respectivamente, em um pacote de controle.
OCTET_MULT: Usado para dividir o tamanho dos dados em dois bytes.
MAX_PACKET_SIZE: Tamanho máximo do pacote que pode ser enviado/recebido.
Funções:
create_control_packet:

Objetivo: Criar um pacote de controle.
Parâmetros:
uint8_t control: Código de controle (ex: CONTROL_START).
const char* filename: Nome do arquivo.
size_t file_size: Tamanho do arquivo.
uint8_t* packet: Buffer onde o pacote será escrito.
Funcionamento:
A função cria um pacote de controle contendo informações como o tamanho e o nome do arquivo. A estrutura é definida com códigos de controle, seguidos pelos tipos e valores correspondentes.
send_control_packet:

Objetivo: Enviar um pacote de controle.
Parâmetros:
uint8_t control: Código de controle.
const char* filename: Nome do arquivo.
size_t file_size: Tamanho do arquivo.
Funcionamento:
A função cria um pacote de controle e depois o envia através da camada de ligação.
send_data_packet:

Objetivo: Enviar um pacote de dados.
Parâmetros:
const uint8_t* data: Dados a serem enviados.
size_t length: Tamanho dos dados.
Funcionamento:
A função cria um pacote de dados e depois o envia.
send:

Objetivo: Enviar um arquivo.
Parâmetros:
const char* filename: Nome do arquivo a ser enviado.
Funcionamento:
Abre o arquivo, envia um pacote de controle de início, lê e envia o arquivo em pacotes de dados e, por fim, envia um pacote de controle de término.
read_control_packet:

Objetivo: Ler um pacote de controle e extrair informações dele.
Parâmetros:
uint8_t control: Código de controle esperado.
uint8_t* buf: Buffer contendo o pacote de controle.
size_t* file_size: Para armazenar o tamanho do arquivo extraído.
char* received_filename: Para armazenar o nome do arquivo extraído.
Funcionamento:
A função lê o pacote de controle e extrai informações como o tamanho e o nome do arquivo.
receive:

Objetivo: Receber um arquivo.
Parâmetros:
const char* filename: Nome do arquivo onde os dados recebidos serão salvos.
Funcionamento:
A função espera e lê um pacote de controle de início, depois lê pacotes de dados até que receba um pacote de controle de término.
applicationLayer:

Objetivo: Estabelecer a conexão e coordenar o envio/recepção de um arquivo.
Parâmetros: Diversos parâmetros para configurar a camada de ligação e especificar o arquivo a ser enviado/recebido.
Funcionamento:
A função configura a camada de ligação com base nos parâmetros fornecidos, estabelece uma conexão, e depois, dependendo do modo (transmissor ou receptor), invoca a função send ou receive. Por fim, encerra a conexão.
Explicação adicional:
O código implementa uma transferência simples de arquivos através de uma conexão serial. Ele usa pacotes de controle para sinalizar o início e o fim da transmissão e para fornecer metadados sobre o arquivo (nome e tamanho). Durante a transmissão real, o arquivo é lido em blocos e cada bloco é enviado como um pacote de dados.



link_layer.c

Estruturas de Dados e Definições:

LinkLayerRole enumera os papéis que o dispositivo pode desempenhar: transmissor (LlTx) ou receptor (LlRx).
data_holder_s e alarm_config_s são estruturas que mantêm os dados para transmissão e as configurações do alarme, respectivamente.
Diversas constantes, como FLAG, ESC, etc., são provavelmente usadas para codificar e decodificar dados.
Funções de Interface de Protocolo:

llopen: Inicializa a conexão, decidindo se a máquina atuará como transmissor ou receptor.
llwrite: Envia dados se a máquina for um transmissor.
llread: Lê dados se a máquina for um receptor.
llclose: Fecha a conexão, desfazendo qualquer inicialização feita por llopen.
Funções de Manipulação de Quadros (frames):

stuff_data e destuff_data: Estas funções codificam e decodificam os dados para garantir que certos caracteres (como FLAG e ESC) sejam transmitidos corretamente, mesmo se estiverem nos próprios dados.
build_supervision_frame e build_information_frame: Constroem quadros de supervisão e informação, respectivamente.
read_supervision_frame e read_information_frame: Leem quadros de supervisão e informação, respectivamente.
Funções do Receptor:

open_receptor e close_receptor: Iniciam e fecham a conexão no lado receptor.
connect_receptor e disconnect_receptor: Estabelecem e encerram a conexão com o transmissor.
receive_packet: Recebe um pacote de dados.
Funções do Transmissor:

Similar ao receptor, tem funções para abrir, fechar, conectar e desconectar. Além disso, possui um manipulador de sinal (alarm_handler) que parece ser chamado sempre que um alarme dispara (possivelmente para tratar retransmissões após timeouts).
Comunicação Serial:

O código usa a biblioteca termios para configurar e interagir com a porta serial, permitindo comunicação ponto a ponto.
O fluxo típico parece ser:

A máquina decide se quer ser transmissor ou receptor usando llopen.
Se for transmissor, ela usa llwrite para enviar dados. Se for receptor, ela usa llread para ler dados.
Quando terminado, llclose é chamado para limpar.
As funções de codificação/decodificação garantem que os dados sejam transmitidos sem ambiguidades (por exemplo, se você quer enviar a "bandeira" real como parte de seus dados, não quer que ela seja confundida com o delimitador de quadro).


ALARME:

O alarme, na contextura de protocolos de comunicação de link de dados, é frequentemente utilizado como um mecanismo de temporização para lidar com possíveis falhas na transmissão.

Aqui está o papel principal do alarme neste contexto:

Timeout e Retransmissão:
Timeout: Quando o transmissor envia um quadro de dados, ele espera por uma confirmação do receptor. Se a confirmação não for recebida dentro de um certo período de tempo (por exemplo, devido a perda do quadro de dados ou da confirmação), o transmissor precisa reenviar o quadro. Esse período de tempo é definido por um "timeout".

Retransmissão: Se o transmissor não receber uma confirmação antes do timeout, assume-se que o quadro foi perdido ou corrompido durante a transmissão, ou que a confirmação foi perdida. Portanto, o transmissor retransmite o quadro.

Configuração do Alarme: O alarme é configurado para disparar após um determinado período de tempo (o timeout). Se o transmissor não receber uma confirmação até que o alarme dispare, uma função (frequentemente chamada de "handler" ou "manipulador de alarme") será invocada. Esta função, normalmente, cuidará da retransmissão do quadro.

Prevenindo Espera Indefinida: Sem um mecanismo de timeout, o transmissor poderia ficar esperando indefinidamente por uma confirmação que nunca chegará (por exemplo, se a confirmação for perdida). O alarme evita essa espera indefinida, garantindo que o transmissor tome uma ação após um certo tempo, seja retransmitindo o quadro ou tentando resolver o problema de outra forma.

No código que você forneceu anteriormente, o alarm_handler provavelmente é a função invocada quando o alarme dispara. Essa função geralmente lida com o procedimento de retransmissão e pode atualizar contadores ou logs indicando que uma retransmissão foi necessária.
